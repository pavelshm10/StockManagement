/*
    MIT License http://www.opensource.org/licenses/mit-license.php
    Author Tobias Koppers @sokra, Zackary Jackson @ScriptedAlchemy
*/
'use strict';
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const normalize_webpack_path_1 = require("@module-federation/sdk/normalize-webpack-path");
const sdk_1 = require("@module-federation/sdk");
const options_1 = require("../container/options");
const resolveMatchedConfigs_1 = require("./resolveMatchedConfigs");
const utils_1 = require("./utils");
const ConsumeSharedFallbackDependency_1 = __importDefault(require("./ConsumeSharedFallbackDependency"));
const ConsumeSharedModule_1 = __importDefault(require("./ConsumeSharedModule"));
const ConsumeSharedRuntimeModule_1 = __importDefault(require("./ConsumeSharedRuntimeModule"));
const ProvideForSharedDependency_1 = __importDefault(require("./ProvideForSharedDependency"));
const FederationRuntimePlugin_1 = __importDefault(require("../container/runtime/FederationRuntimePlugin"));
const ShareRuntimeModule_1 = __importDefault(require("./ShareRuntimeModule"));
const utils_2 = require("../../utils");
const path_1 = __importDefault(require("path"));
const runtime_core_1 = require("@module-federation/runtime-tools/runtime-core");
const ModuleNotFoundError = require((0, normalize_webpack_path_1.normalizeWebpackPath)('webpack/lib/ModuleNotFoundError'));
const { RuntimeGlobals } = require((0, normalize_webpack_path_1.normalizeWebpackPath)('webpack'));
const LazySet = require((0, normalize_webpack_path_1.normalizeWebpackPath)('webpack/lib/util/LazySet'));
const WebpackError = require((0, normalize_webpack_path_1.normalizeWebpackPath)('webpack/lib/WebpackError'));
const validate = (0, utils_2.createSchemaValidation)(
//eslint-disable-next-line
require('../../schemas/sharing/ConsumeSharedPlugin.check.js').validate, () => require('../../schemas/sharing/ConsumeSharedPlugin').default, {
    name: 'Consume Shared Plugin',
    baseDataPath: 'options',
});
const RESOLVE_OPTIONS = {
    dependencyType: 'esm',
};
const PLUGIN_NAME = 'ConsumeSharedPlugin';
class ConsumeSharedPlugin {
    constructor(options) {
        if (typeof options !== 'string') {
            validate(options);
        }
        this._consumes = (0, options_1.parseOptions)(options.consumes, (item, key) => {
            if (Array.isArray(item))
                throw new Error('Unexpected array in options');
            //@ts-ignore
            const result = item === key || !(0, sdk_1.isRequiredVersion)(item)
                ? // item is a request/key
                    {
                        import: key,
                        shareScope: options.shareScope || 'default',
                        shareKey: key,
                        requiredVersion: undefined,
                        packageName: undefined,
                        strictVersion: false,
                        singleton: false,
                        eager: false,
                        issuerLayer: undefined,
                        layer: undefined,
                        request: key,
                        include: undefined,
                        exclude: undefined,
                    }
                : // key is a request/key
                    // item is a version
                    {
                        import: key,
                        shareScope: options.shareScope || 'default',
                        shareKey: key,
                        // webpack internal semver has some issue, use runtime semver , related issue: https://github.com/webpack/webpack/issues/17756
                        requiredVersion: item,
                        strictVersion: true,
                        packageName: undefined,
                        singleton: false,
                        eager: false,
                        issuerLayer: undefined,
                        layer: undefined,
                        request: key,
                        include: undefined,
                        exclude: undefined,
                    };
            return result;
        }, (item, key) => {
            const request = item.request || key;
            return {
                import: item.import === false ? undefined : item.import || request,
                shareScope: item.shareScope || options.shareScope || 'default',
                shareKey: item.shareKey || request,
                requiredVersion: item.requiredVersion === false
                    ? false
                    : // @ts-ignore  webpack internal semver has some issue, use runtime semver , related issue: https://github.com/webpack/webpack/issues/17756
                        item.requiredVersion,
                strictVersion: typeof item.strictVersion === 'boolean'
                    ? item.strictVersion
                    : item.import !== false && !item.singleton,
                packageName: item.packageName,
                singleton: !!item.singleton,
                eager: !!item.eager,
                issuerLayer: item.issuerLayer ? item.issuerLayer : undefined,
                layer: item.layer ? item.layer : undefined,
                request,
                include: item.include,
                exclude: item.exclude,
            };
        });
    }
    apply(compiler) {
        new FederationRuntimePlugin_1.default().apply(compiler);
        process.env['FEDERATION_WEBPACK_PATH'] =
            process.env['FEDERATION_WEBPACK_PATH'] || (0, normalize_webpack_path_1.getWebpackPath)(compiler);
        compiler.hooks.thisCompilation.tap(PLUGIN_NAME, (compilation, { normalModuleFactory }) => {
            compilation.dependencyFactories.set(ConsumeSharedFallbackDependency_1.default, normalModuleFactory);
            let unresolvedConsumes, resolvedConsumes, prefixedConsumes;
            const promise = (0, resolveMatchedConfigs_1.resolveMatchedConfigs)(compilation, this._consumes).then(({ resolved, unresolved, prefixed }) => {
                resolvedConsumes = resolved;
                unresolvedConsumes = unresolved;
                prefixedConsumes = prefixed;
            });
            const resolver = compilation.resolverFactory.get('normal', RESOLVE_OPTIONS);
            const createConsumeSharedModule = (context, request, config) => {
                const requiredVersionWarning = (details) => {
                    const error = new WebpackError(`No required version specified and unable to automatically determine one. ${details}`);
                    error.file = `shared module ${request}`;
                    compilation.warnings.push(error);
                };
                const directFallback = config.import &&
                    /^(\.\.?(\/|$)|\/|[A-Za-z]:|\\\\)/.test(config.import);
                return Promise.all([
                    new Promise((resolve) => {
                        if (!config.import)
                            return resolve(undefined);
                        const resolveContext = {
                            fileDependencies: new LazySet(),
                            contextDependencies: new LazySet(),
                            missingDependencies: new LazySet(),
                        };
                        resolver.resolve({}, directFallback ? compiler.context : context, config.import, resolveContext, (err, result) => {
                            compilation.contextDependencies.addAll(resolveContext.contextDependencies);
                            compilation.fileDependencies.addAll(resolveContext.fileDependencies);
                            compilation.missingDependencies.addAll(resolveContext.missingDependencies);
                            if (err) {
                                compilation.errors.push(new ModuleNotFoundError(null, err, {
                                    name: `resolving fallback for shared module ${request}`,
                                }));
                                return resolve(undefined);
                            }
                            //@ts-ignore
                            resolve(result);
                        });
                    }),
                    new Promise((resolve) => {
                        if (config.requiredVersion !== undefined) {
                            return resolve(config.requiredVersion);
                        }
                        let packageName = config.packageName;
                        if (packageName === undefined) {
                            if (/^(\/|[A-Za-z]:|\\\\)/.test(request)) {
                                // For relative or absolute requests we don't automatically use a packageName.
                                // If wished one can specify one with the packageName option.
                                return resolve(undefined);
                            }
                            const match = /^((?:@[^\\/]+[\\/])?[^\\/]+)/.exec(request);
                            if (!match) {
                                requiredVersionWarning('Unable to extract the package name from request.');
                                return resolve(undefined);
                            }
                            packageName = match[0];
                        }
                        (0, utils_1.getDescriptionFile)(compilation.inputFileSystem, context, ['package.json'], (err, result, checkedDescriptionFilePaths) => {
                            if (err) {
                                requiredVersionWarning(`Unable to read description file: ${err}`);
                                return resolve(undefined);
                            }
                            const { data } = /** @type {DescriptionFile} */ result || {};
                            if (!data) {
                                if (checkedDescriptionFilePaths?.length) {
                                    requiredVersionWarning([
                                        `Unable to find required version for "${packageName}" in description file/s`,
                                        checkedDescriptionFilePaths.join('\n'),
                                        'It need to be in dependencies, devDependencies or peerDependencies.',
                                    ].join('\n'));
                                }
                                else {
                                    requiredVersionWarning(`Unable to find description file in ${context}.`);
                                }
                                return resolve(undefined);
                            }
                            if (data['name'] === packageName) {
                                // Package self-referencing
                                return resolve(undefined);
                            }
                            const requiredVersion = (0, utils_1.getRequiredVersionFromDescriptionFile)(data, packageName);
                            //TODO: align with webpck semver parser again
                            // @ts-ignore  webpack internal semver has some issue, use runtime semver , related issue: https://github.com/webpack/webpack/issues/17756
                            resolve(requiredVersion);
                        }, (result) => {
                            if (!result)
                                return false;
                            const { data } = result;
                            const maybeRequiredVersion = (0, utils_1.getRequiredVersionFromDescriptionFile)(data, packageName);
                            return (data['name'] === packageName ||
                                typeof maybeRequiredVersion === 'string');
                        });
                    }),
                ]).then(async ([importResolved, requiredVersion]) => {
                    // Helper function to create fallback module
                    const createFallbackModule = () => new ConsumeSharedModule_1.default(directFallback ? compiler.context : context, {
                        ...config,
                        importResolved: undefined,
                        import: undefined,
                        requiredVersion: false,
                    });
                    // Helper function to create normal module
                    const createNormalModule = () => new ConsumeSharedModule_1.default(directFallback ? compiler.context : context, {
                        ...config,
                        importResolved,
                        import: importResolved ? config.import : undefined,
                        requiredVersion,
                    });
                    // Check for include version first
                    if (config.include && typeof config.include.version === 'string') {
                        if (!importResolved) {
                            return createNormalModule();
                        }
                        return new Promise((resolveFilter) => {
                            (0, utils_1.getDescriptionFile)(compilation.inputFileSystem, path_1.default.dirname(importResolved), ['package.json'], (err, result) => {
                                if (err) {
                                    return resolveFilter(createNormalModule());
                                }
                                const { data } = result || {};
                                if (!data || !data['version']) {
                                    return resolveFilter(createNormalModule());
                                }
                                // Only include if version satisfies the include constraint
                                const includeVersion = config.include.version;
                                if ((0, runtime_core_1.satisfy)(data['version'], includeVersion)) {
                                    // Validate singleton usage with include.version
                                    if (config.singleton) {
                                        (0, utils_1.addSingletonFilterWarning)(compilation, config.shareKey, 'include', 'version', includeVersion, request, importResolved);
                                    }
                                    return resolveFilter(createNormalModule());
                                }
                                // Version does not satisfy include filter
                                const error = new WebpackError(`Shared module "${request}" version "${data['version']}" does not satisfy include filter "${includeVersion}"`);
                                error.file = `shared module ${request}`;
                                compilation.warnings.push(error);
                                return resolveFilter(createFallbackModule());
                            });
                        });
                    }
                    // Check for exclude version
                    if (config.exclude && typeof config.exclude.version === 'string') {
                        if (!importResolved) {
                            return createNormalModule();
                        }
                        return new Promise((resolveFilter) => {
                            (0, utils_1.getDescriptionFile)(compilation.inputFileSystem, path_1.default.dirname(importResolved), ['package.json'], (err, result) => {
                                if (err) {
                                    return resolveFilter(createNormalModule());
                                }
                                const { data } = result || {};
                                if (!data || !data['version']) {
                                    return resolveFilter(createNormalModule());
                                }
                                const excludeVersion = config.exclude.version;
                                if ((0, runtime_core_1.satisfy)(data['version'], excludeVersion)) {
                                    // Version matches exclude filter - exclude this module
                                    const error = new WebpackError(`Shared module "${request}" version "${data['version']}" matches exclude filter "${excludeVersion}"`);
                                    error.file = `shared module ${request}`;
                                    compilation.warnings.push(error);
                                    return resolveFilter(createFallbackModule());
                                }
                                // Validate singleton usage with exclude.version
                                if (config.singleton) {
                                    (0, utils_1.addSingletonFilterWarning)(compilation, config.shareKey, 'exclude', 'version', excludeVersion, request, importResolved);
                                }
                                return resolveFilter(createNormalModule());
                            });
                        });
                    }
                    return createNormalModule();
                });
            };
            normalModuleFactory.hooks.factorize.tapPromise(PLUGIN_NAME, async (resolveData) => {
                const { context, request, dependencies, contextInfo } = resolveData;
                // wait for resolving to be complete
                return promise.then(() => {
                    if (dependencies[0] instanceof ConsumeSharedFallbackDependency_1.default ||
                        dependencies[0] instanceof ProvideForSharedDependency_1.default) {
                        return;
                    }
                    const match = unresolvedConsumes.get((0, utils_1.createLookupKeyForSharing)(request, contextInfo.issuerLayer));
                    if (match !== undefined) {
                        return createConsumeSharedModule(context, request, match);
                    }
                    for (const [prefix, options] of prefixedConsumes) {
                        const lookup = options.request || prefix;
                        if (request.startsWith(lookup)) {
                            const remainder = request.slice(lookup.length);
                            // Apply request filters if defined
                            if (!(0, utils_1.testRequestFilters)(remainder, options.include?.request, options.exclude?.request)) {
                                continue; // Skip this match if filters don't pass
                            }
                            const shareKey = options.shareKey + remainder;
                            return createConsumeSharedModule(context, request, {
                                ...options,
                                import: options.import
                                    ? options.import + remainder
                                    : undefined,
                                shareKey,
                                layer: options.layer || contextInfo.issuerLayer,
                            });
                        }
                    }
                    return;
                });
            });
            normalModuleFactory.hooks.createModule.tapPromise(PLUGIN_NAME, ({ resource }, { context, dependencies }) => {
                if (dependencies[0] instanceof ConsumeSharedFallbackDependency_1.default ||
                    dependencies[0] instanceof ProvideForSharedDependency_1.default) {
                    return Promise.resolve();
                }
                if (resource) {
                    const options = resolvedConsumes.get(resource);
                    if (options !== undefined) {
                        return createConsumeSharedModule(context, resource, options);
                    }
                }
                return Promise.resolve();
            });
            compilation.hooks.additionalTreeRuntimeRequirements.tap(PLUGIN_NAME, (chunk, set) => {
                set.add(RuntimeGlobals.module);
                set.add(RuntimeGlobals.moduleCache);
                set.add(RuntimeGlobals.moduleFactoriesAddOnly);
                set.add(RuntimeGlobals.shareScopeMap);
                set.add(RuntimeGlobals.initializeSharing);
                set.add(RuntimeGlobals.hasOwnProperty);
                compilation.addRuntimeModule(chunk, new ConsumeSharedRuntimeModule_1.default(set));
                // FIXME: need to remove webpack internal inject ShareRuntimeModule, otherwise there will be two ShareRuntimeModule
                compilation.addRuntimeModule(chunk, new ShareRuntimeModule_1.default());
            });
        });
    }
}
exports.default = ConsumeSharedPlugin;
//# sourceMappingURL=ConsumeSharedPlugin.js.map